Grazie per avermi fornito gli appunti del professore. Ora ti trascrivo le **formule** esatte secondo il suo metodo e ti fornisco una **implementazione in pseudocodice** della DCT e della IDCT, seguendo esattamente quanto richiesto.

---

## üî¢ **Formula della DCT (monodimensionale) secondo gli appunti**

Dati un vettore $v \in \mathbb{R}^N$, i coefficienti della DCT sono definiti come:

$$
a_k = \frac{v \cdot w_k}{w_k \cdot w_k}
= \frac{\sum_{i=0}^{N-1} v_i \cdot \cos\left( \frac{k\pi(2i + 1)}{2N} \right)}{N} \quad \text{se } k = 0
$$

$$
a_k = \frac{\sum_{i=0}^{N-1} v_i \cdot \cos\left( \frac{k\pi(2i + 1)}{2N} \right)}{N/2} \quad \text{se } k \ne 0
$$

dove $w_k \cdot w_k = N$ per $k=0$, e $N/2$ altrimenti.

---

## üîÅ **Formula della IDCT (monodimensionale)**

Per ottenere $v$ dai coefficienti $a_k$, si usa:

$$
v_j = \sum_{k=0}^{N-1} a_k \cdot \cos\left( \frac{k\pi(2j + 1)}{2N} \right)
$$

Non serve alcuna normalizzazione perch√© i coefficienti $a_k$ erano gi√† stati normalizzati nella DCT.

---

## üìú **Pseudocodice DCT (1D)**

```plaintext
function DCT(v: array of float, N: int) -> array of float:
    let a = array of float of size N

    for k from 0 to N-1:
        denom = N if k == 0 else N / 2
        sum = 0
        for i from 0 to N-1:
            sum += v[i] * cos((k * œÄ * (2*i + 1)) / (2 * N))
        a[k] = sum / denom

    return a
```

---

## üìú **Pseudocodice IDCT (1D)**

```plaintext
function IDCT(a: array of float, N: int) -> array of float:
    let v = array of float of size N

    for j from 0 to N-1:
        sum = 0
        for k from 0 to N-1:
            sum += a[k] * cos((k * œÄ * (2*j + 1)) / (2 * N))
        v[j] = sum

    return v
```

---

Se vuoi, posso ora aiutarti con:

* la **versione DCT2** (applicando DCT alle righe e poi alle colonne),
* e poi con la **versione in C++**, partendo da queste formule.

Ti interessa proseguire con la DCT2 fatta in casa in pseudocodice o direttamente il codice C++?


per tinyfiledialogs

‚ùó Requisiti (Linux):

Se su Linux non ti appare il dialogo, assicurati di avere:

    zenity, kdialog, Xdialog o python3-tk installati

Puoi installarli ad esempio con:

sudo apt install zenity

Nota su utilizzo di zenity e variabili d‚Äôambiente in C++ su Ubuntu

    zenity √® un tool da terminale per creare finestre di dialogo GUI molto semplici.

    Quando si esegue un programma C++ da VSCode o IDE su Ubuntu, la shell potrebbe non avere tutte le variabili d‚Äôambiente configurate come in un terminale normale.

    In particolare, la variabile DISPLAY (necessaria per mostrare finestre GUI su X11) deve essere correttamente esportata.

    Se si esegue il programma da terminale Ubuntu normale, zenity funziona correttamente perch√© l‚Äôambiente √® configurato correttamente (con DISPLAY, PATH ecc).

    Da VSCode, pu√≤ servire esportare manualmente DISPLAY=:0 o lanciare VSCode da terminale con l‚Äôambiente giusto.

    Per eseguire zenity da C++ (es. con system("zenity ...")), bisogna assicurarsi che l‚Äôambiente di esecuzione abbia accesso a DISPLAY e alle librerie grafiche.

    Errori come symbol lookup error: ... libpthread.so.0: undefined symbol: __libc_pthread_init possono essere causati da conflitti di librerie, spesso se si usa snap o ambienti isolati che non trovano le librerie corrette.



    Spiegazione dettagliata (utile per la relazione) (OpenCV DCT e IDCT supportano solo F pari):

    Crop bordi: per semplicit√†, scartiamo gli eventuali bordi dell‚Äôimmagine che non rientrano in un blocco completo di dimensione f x f.

    Suddivisione in blocchi: suddividiamo l‚Äôimmagine in finestrelle quadrate di lato f.

    DCT2: applicata separatamente su ogni blocco (trasformazione discreta coseno 2D).

    Soglia d: si azzerano tutti i coefficienti DCT per cui la somma degli indici (riga + colonna) supera la soglia d, eliminando le frequenze pi√π alte.

    IDCT2: trasformazione inversa per ottenere il blocco modificato in dominio spaziale.

    Clamping: assicuriamo che i valori risultanti siano validi per un‚Äôimmagine grayscale (0‚Äì255).

    Ricostruzione immagine: i blocchi modificati vengono rimessi insieme per formare l‚Äôimmagine finale.

    Visualizzazione: affianchiamo immagine originale e modificata per confronto.